; Important : each instruction executes in 2 cycles = Tclk*2
;CONSTANT delay_1us_constant,18		; 2+4*A+2=100 => A=0x18 for clk=100MHz
CONSTANT delay_1us_constant,0b		; 2+4*A+2=100 => A=0x0b for clk=48MHz

CONSTANT uart_status_port,81
CONSTANT uart_port,80
CONSTANT spi_clk_div_port,F4
CONSTANT spi_receive_port,F3
CONSTANT spi_transmit_port,F2
CONSTANT spi_cs_ctl_port,F0

CONSTANT UARTavailable,01

NAMEREG s0,reg0
NAMEREG s1,reg1
NAMEREG s2,reg2
NAMEREG s3,reg3
NAMEREG s4,reg4

NAMEREG sE,dummy
NAMEREG sF,data

ADDRESS 000
coldstart:
	call delay_1ms				; give time to external logic to settle..

	call crlf
	load s0,CHAR_EXCLA
	call putc
	load s0,CHAR_r
	call putc
	load s0,CHAR_e
	call putc
	load s0,CHAR_s
	call putc
	load s0,CHAR_e
	call putc
	load s0,CHAR_t
	call putc
	load s0,CHAR_EXCLA
	call putc
	call crlf
main:
	load s0,CHAR_m
	call putc
	load s0,CHAR_o
	call putc
	load s0,CHAR_n
	call putc
	load s0,CHAR_GREATER
	call putc
	call getc
	compare data,CHAR_s
	jump Z,spi_out
	compare data,CHAR_QUEST
	jump Z,help
ret_main:
	call crlf
	jump main

spi_out:
	load dummy,00
	output dummy,spi_clk_div_port
	load dummy,fe
	output dummy,spi_cs_ctl_port
	load s0,CHAR_EQUAL
	call putc
;	call get1hex
	call get2hex
	output data,spi_transmit_port
	load s0,CHAR_EQUAL
	call putc
	input s0,f0
	call put2hex
	jump ret_main

help:
	call crlf
	load s0,CHAR_QUEST
	call putc
	call space
	load s0,CHAR_h
	call putc
	load s0,CHAR_e
	call putc
	load s0,CHAR_l
	call putc
	load s0,CHAR_p
	call putc

	call crlf
	load s0,CHAR_s
	call putc
	call space
	load s0,CHAR_s
	call putc
	load s0,CHAR_p
	call putc
	load s0,CHAR_i
	call putc
	load s0,CHAR_UNDER
	call putc
	load s0,CHAR_o
	call putc
	load s0,CHAR_u
	call putc
	load s0,CHAR_t
	call putc
	jump ret_main
	
; input : s0=byte to print as hex
; clobbers s0, s1
put2hex:
	load s1,s0
	sr0 s0
	sr0 s0
	sr0 s0
	sr0 s0
	call put1hex
	load s0,s1
put1hex:
	and s0,0f
	compare s0,0a
	jump C,put1hex1
	add s0,7
put1hex1:
	add s0,30
	jump putc

; return in data
; clobbers s0
get1hex:
	call getc_ne
	load s0,data
	sub data,30		; '0'
	compare data,0a	; '9'-'0'+1
	jump C,get1hex2
	sub data,11		; 'A'-'0'
	compare data,06	; 'F'-'A'+1
	jump C,get1hex1
	sub data,20		; 'a'-'A'
	compare data,06	; 'f'-'a'+1
	jump NC,get1hex
get1hex1:
	add data,0a
get1hex2:
	jump putc

; return in data
; clobbers s0, s1
get2hex:
	call get1hex
	load s1,data
	sl0 s1
	sl0 s1
	sl0 s1
	sl0 s1
	call get1hex
	or data,s1
	return

; clobbers s0, dummy
crlf:
	load s0,CHAR_CR
	call putc
	load s0,CHAR_LF
	jump putc

; clobbers s0, dummy
space:
	load s0,CHAR_SPACE
	jump putc

; return in data
getc_ne:
	load data,00
	ENABLE INTERRUPT
loop:
	test data,ff
	jump Z,loop
	return

; return in data
; clobbers s0, dummy
getc:
	call getc_ne
	load s0,data
; pass-through to putc here to spare 2 words
; ..............

; input in s0
; clobbers dummy
putc:
	input dummy,uart_status_port
	test dummy,01
	jump NZ,putc
	output s0,uart_port
	return

delay_1us: LOAD reg0,delay_1us_constant	; routine takes 2+4*A+2 cycles
_wait_1us: SUB reg0,01			; (2+4*A+2)*Tclk=10e-6s => A=(Fclk/10e6-4)/4
	JUMP NZ,_wait_1us			; => A=7 for Fclk=32MHz
	RETURN
delay_40us: LOAD reg1,22		; routine takes 2+(2+(4+4*A)+4)*B+2 cycles
_wait_40us: CALL delay_1us		; (2+(2+(4+4*A)+4)*B+2)*Tclk=40e-6s
	SUB reg1,01					; => B=(Fclk/25000-4)/(10+4*A)=33.578~=34=0x22
	JUMP NZ,_wait_40us
	RETURN
delay_1ms: LOAD reg2,19			;25 x 40us = 1ms
_wait_1ms: CALL delay_40us		; 1000000=A*40000+(2+3A)*62.5
	SUB reg2,01					; A=(1000000-2*62.5)/(40000+3*62.5)
	JUMP NZ,_wait_1ms			; A=24.880~=25=0x19
	RETURN
delay_20ms: LOAD reg3,14			;20 x 1ms = 20ms  (20=0x14)
_wait_20ms: CALL delay_1ms
	SUB reg3,01
	JUMP NZ,_wait_20ms
	RETURN
delay_1s: LOAD reg4,32				;50 x 20ms = 1000ms (50=0x32)
_wait_1s: CALL delay_20ms
	SUB reg4,01
	JUMP NZ,_wait_1s
	RETURN

isr:
	input data,uart_port
	returni DISABLE

ADDRESS 3ff
	jump isr

CONSTANT CHAR_A,41
CONSTANT CHAR_B,42
CONSTANT CHAR_e,65
CONSTANT CHAR_h,68
CONSTANT CHAR_i,69
CONSTANT CHAR_l,6c
CONSTANT CHAR_m,6d
CONSTANT CHAR_n,6e
CONSTANT CHAR_o,6f
CONSTANT CHAR_p,70
CONSTANT CHAR_r,72
CONSTANT CHAR_s,73
CONSTANT CHAR_t,74
CONSTANT CHAR_u,75
CONSTANT CHAR_UNDER,5f
CONSTANT CHAR_SPACE,20
CONSTANT CHAR_EQUAL,3d
CONSTANT CHAR_GREATER,3E
CONSTANT CHAR_EXCLA,21
CONSTANT CHAR_QUEST,3f
CONSTANT CHAR_LF,0a
CONSTANT CHAR_CR,0d
